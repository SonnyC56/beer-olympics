/**
 * Multi-Station Scheduling Types
 * Core types for managing game stations and match scheduling
 */
import type { Match } from './tournament';
/**
 * Physical game station where matches are played
 */
export interface Station {
    _type: 'station';
    id: string;
    name: string;
    tournamentId: string;
    description?: string;
    location?: string;
    capacity?: number;
    gameTypes?: string[];
    equipment?: string[];
    isActive: boolean;
    status: 'available' | 'occupied' | 'maintenance' | 'reserved';
    currentMatchId?: string;
    currentMatchStartTime?: string;
    totalMatchesPlayed?: number;
    averageMatchDuration?: number;
    createdAt: string;
    updatedAt: string;
}
/**
 * Time slot for scheduling matches
 */
export interface ScheduleSlot {
    _type: 'schedule_slot';
    id: string;
    tournamentId: string;
    startTime: string;
    endTime: string;
    duration: number;
    stationId: string;
    stationName?: string;
    matchId?: string;
    round?: number;
    status: 'available' | 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
    bufferBefore?: number;
    bufferAfter?: number;
    hasConflict?: boolean;
    conflictReason?: string;
    conflictingSlotIds?: string[];
    createdAt: string;
    updatedAt: string;
}
/**
 * Player availability constraints
 */
export interface PlayerAvailability {
    _type: 'player_availability';
    playerId: string;
    tournamentId: string;
    availableWindows: TimeWindow[];
    blackoutPeriods: TimeWindow[];
    preferredTimes?: TimeWindow[];
    preferredStations?: string[];
    minRestBetweenMatches?: number;
    maxMatchesPerDay?: number;
    maxConsecutiveMatches?: number;
    updatedAt: string;
}
/**
 * Time window for availability
 */
export interface TimeWindow {
    startTime: string;
    endTime: string;
    recurring?: RecurringPattern;
    priority?: 'required' | 'preferred' | 'optional';
    note?: string;
}
/**
 * Recurring pattern for time windows
 */
export interface RecurringPattern {
    frequency: 'daily' | 'weekly' | 'monthly';
    interval: number;
    daysOfWeek?: number[];
    endDate?: string;
    exceptions?: string[];
}
/**
 * Schedule conflict information
 */
export interface ScheduleConflict {
    _type: 'schedule_conflict';
    id: string;
    tournamentId: string;
    type: 'player_double_booked' | 'station_overlap' | 'insufficient_rest' | 'availability_violation';
    severity: 'warning' | 'error' | 'critical';
    affectedSlotIds: string[];
    affectedMatchIds: string[];
    affectedPlayerIds?: string[];
    affectedStationIds?: string[];
    description: string;
    suggestedResolution?: string;
    isResolved: boolean;
    resolutionAction?: string;
    resolvedBy?: string;
    resolvedAt?: string;
    detectedAt: string;
}
/**
 * Scheduling algorithm configuration
 */
export interface SchedulingConfig {
    algorithm: 'greedy' | 'backtracking' | 'genetic' | 'constraint_satisfaction';
    startTime: string;
    endTime: string;
    matchDuration: number;
    bufferTime: number;
    maxStations: number;
    stationPreferences?: {
        [matchId: string]: string[];
    };
    minRestTime: number;
    maxConcurrentMatches?: number;
    respectAvailability: boolean;
    optimizationGoals: SchedulingOptimizationGoal[];
    allowFlexibleStartTimes?: boolean;
    allowStationChanges?: boolean;
    prioritizeHigherSeeds?: boolean;
    groupByRound?: boolean;
}
/**
 * Optimization goals for scheduling
 */
export interface SchedulingOptimizationGoal {
    type: 'minimize_total_time' | 'maximize_station_usage' | 'minimize_player_wait' | 'balance_station_load' | 'minimize_conflicts';
    weight: number;
    constraints?: any;
}
/**
 * Schedule generation result
 */
export interface ScheduleResult {
    success: boolean;
    schedule: ScheduleSlot[];
    conflicts: ScheduleConflict[];
    totalDuration: number;
    stationUtilization: {
        [stationId: string]: number;
    };
    averagePlayerWaitTime: number;
    maxPlayerWaitTime: number;
    score: number;
    scoreBreakdown: {
        [goalType: string]: number;
    };
    algorithmUsed: string;
    generationTime: number;
    iterations?: number;
    backtrackCount?: number;
}
/**
 * Real-time schedule update
 */
export interface ScheduleUpdate {
    _type: 'schedule_update';
    tournamentId: string;
    updateType: 'delay' | 'cancellation' | 'reschedule' | 'station_change' | 'duration_change';
    affectedSlotIds: string[];
    affectedMatchIds: string[];
    reason: string;
    previousValues?: Partial<ScheduleSlot>[];
    newValues: Partial<ScheduleSlot>[];
    cascadingUpdates?: ScheduleUpdate[];
    updatedBy: string;
    updatedAt: string;
    autoGenerated: boolean;
}
/**
 * Station assignment recommendation
 */
export interface StationRecommendation {
    matchId: string;
    recommendedStations: {
        stationId: string;
        score: number;
        reasons: string[];
    }[];
    constraints: string[];
}
/**
 * Schedule analytics
 */
export interface ScheduleAnalytics {
    tournamentId: string;
    generatedAt: string;
    tournamentDuration: number;
    averageMatchDuration: number;
    totalBufferTime: number;
    stationUtilization: {
        stationId: string;
        utilizationPercentage: number;
        totalMatches: number;
        idleTime: number;
    }[];
    playerWaitTimes: {
        playerId: string;
        averageWaitTime: number;
        maxWaitTime: number;
        totalWaitTime: number;
    }[];
    totalConflicts: number;
    conflictsByType: {
        [type: string]: number;
    };
    resolvedConflicts: number;
    scheduleEfficiency: number;
    recommendedImprovements: string[];
}
/**
 * Match with scheduling information
 */
export interface ScheduledMatch extends Match {
    scheduledSlotId?: string;
    scheduledStartTime?: string;
    scheduledEndTime?: string;
    scheduledStationId?: string;
    scheduledStationName?: string;
    actualStartTime?: string;
    actualEndTime?: string;
    actualDuration?: number;
    delayReason?: string;
    delayMinutes?: number;
    teamAReady?: boolean;
    teamBReady?: boolean;
    stationReady?: boolean;
    refereeReady?: boolean;
}
/**
 * Bulk scheduling request
 */
export interface BulkScheduleRequest {
    tournamentId: string;
    matchIds: string[];
    config: SchedulingConfig;
    constraints?: SchedulingConstraint[];
    preview?: boolean;
}
/**
 * Custom scheduling constraint
 */
export interface SchedulingConstraint {
    type: 'before' | 'after' | 'same_time' | 'different_time' | 'same_station' | 'different_station' | 'time_range';
    matchIds: string[];
    value?: any;
    priority: 'soft' | 'hard';
    reason?: string;
}
/**
 * Schedule export format
 */
export interface ScheduleExport {
    tournament: {
        id: string;
        name: string;
        date: string;
    };
    stations: Station[];
    schedule: {
        round: number;
        slots: {
            time: string;
            station: string;
            match: {
                teamA: string;
                teamB: string;
                event?: string;
            };
        }[];
    }[];
    generatedAt: string;
    format: 'pdf' | 'csv' | 'ical' | 'json';
}
